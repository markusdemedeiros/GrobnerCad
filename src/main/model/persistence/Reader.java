package model.persistence;


import model.FullSystem;
import model.algebraic.*;
import model.geometric.Geometry;
import model.geometric.Point;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.List;

import static java.lang.Math.abs;
import static java.lang.Math.sqrt;

// A reader that can read constraint problems from a file
public class Reader {

    // TODO: Add exception for incorrectly specified system. When generated by my program this will never occur,
    //      since I only save correctly generated files, but I want other programs to be able to interface with
    //      mine via the filesystem. Perhaps utilize the checks in SolverApp, put them here instead once I've
    //      properly refactored SolverApp, Solver, and Analyst to run on FullSystem.

    // TODO: Add comment function in .sys files

    // EFFECTS: Reads a file, returns Fullsystem. Throws IOException if it can't read the file.
    // REQUIRES: Correctly formatted .sys file
    public static FullSystem readSystem(File file) throws IOException {
        List<String> fileContent = Files.readAllLines(file.toPath());
        /* I throw out line 1 assuming it the file is correct. Check and use excpetions instead. */
        List<String> geoStrings = fileContent.subList(fileContent.indexOf("{GEO}"),
                fileContent.indexOf("{ALG}"));
        System.out.println(geoStrings.toString());
        List<String> algStrings = fileContent.subList(fileContent.indexOf("{ALG}"),
                fileContent.size());
        System.out.println(algStrings.toString());

        List<Geometry> geometery = parseGeometry(geoStrings);
        List<Constraint> constraints = parseConstraints(algStrings, geometery);


        return (new FullSystem(geometery, constraints));
    }

    // EFFECTS: Creates list of geometric elements from read strings
    private static List<Geometry> parseGeometry(List<String> geoStrings) {

        List<Geometry> result = new ArrayList<>();
        for (String current : geoStrings.subList(1, geoStrings.size())) {
            String name = current.substring(1, current.indexOf(":") - 2);
            if (current.substring(1, 3).equals("PT")) {
                result.add(parsePoint(current));
            }
            // USE ELSE here to throe exception in the future
        }
        return result;
    }

    // Creates point from sreing representation
    private static Point parsePoint(String toParse) {
        String name = toParse.substring(toParse.indexOf(":") + 2, toParse.indexOf("]"));
        return new Point(name);
    }

    // EFFECTS: Creats list of constraints from read strings and list of read geometry
    private static List<Constraint> parseConstraints(List<String> conStrings, List<Geometry> geometry) {
        List<Constraint> result = new ArrayList<>();
        for (String current : conStrings.subList(1, conStrings.size())) {
            String type = current.substring(1, current.indexOf(" "));
            result.add(readConstraintFromType(type, current, geometry));
        }
        return result;
    }

    // EFFECTS: Gets a constraint, given it's type, it's string representation, and the geometric context
    private static Constraint readConstraintFromType(String type, String toParse, List<Geometry> geometry) {
        Constraint result = null;
        if (type.equals(Constraint.PP_DISTANCE_TYPE)) {
            result = parsePPDistance(toParse, geometry);
        } else if (type.equals(Constraint.PP_COINCIDENT_TYPE)) {
            result = parsePPCoincident(toParse, geometry);
        } else if (type.equals(Constraint.PP_HORIZONTAL_TYPE)) {
            result = parsePPHorizontal(toParse, geometry);
        } else if (type.equals(Constraint.PP_VERTICAL_TYPE)) {
            result = parsePPVertical(toParse, geometry);
        } else if (type.equals(Constraint.P_SETX_CONSTRAINT)) {
            result = parsePSetX(toParse, geometry);
        } else if (type.equals(Constraint.P_SETY_CONSTRAINT)) {
            result = parsePSetY(toParse, geometry);
        }
        // No support for generic constraints, it's okay to ignore the else for now
        return result;
    }

    // EFFECTS: Returns a geometric element by name from list
    // REQUIRES: Unique names in geo
    // Make this type safe by adding generic type? IE can return a POINT I don't have to cast?
    private static Geometry searchGeoByName(String name, List<Geometry> geo) {
        Geometry selected = null;
        for (Geometry element : geo) {
            if (element.getName().equals(name)) {
                selected = element;
            }
        }
        return selected;
    }

    //  ==================================================
    //      CONSTRAINT PARSING CLASSES
    //          EFFECTS: Creates a constraint of type [TYPE] from string representation and geometric context
    // TODO: Move these into their respective classes, somehow. I don't know how to add static
    //      methods to abstract classes, might just do it by hand/comments instead of compiler-enforced
    //          NOTE: The return type can actually just be Constraint. I only use constraint functionality
    //          This might make abstraction easie
    // TODO: Abstract similarities away

    private static PSetYConstraint parsePSetY(String toParse, List<Geometry> geometry) {
        String pt = toParse.substring(toParse.indexOf("[") + 1,
                toParse.indexOf("_"));
        double value = Double.parseDouble(toParse.substring(toParse.lastIndexOf("{") + 1,
                toParse.lastIndexOf("}")));
        String name = toParse.substring(toParse.indexOf(" ") + 1,
                toParse.indexOf(":") - 1);
        return new PSetYConstraint(name, (Point) searchGeoByName(pt, geometry), -1 * value);
    }

    private static PSetXConstraint parsePSetX(String toParse, List<Geometry> geometry) {
        String pt = toParse.substring(toParse.indexOf("[") + 1,
                toParse.indexOf("_"));
        double value = Double.parseDouble(toParse.substring(toParse.lastIndexOf("{") + 1,
                toParse.lastIndexOf("}")));
        String name = toParse.substring(toParse.indexOf(" ") + 1,
                toParse.indexOf(":") - 1);
        return new PSetXConstraint(name, (Point) searchGeoByName(pt, geometry), -1 * value);
    }

    private static PPVerticalConstraint parsePPVertical(String toParse, List<Geometry> geometry) {
        String pt1 = toParse.substring(toParse.indexOf("[") + 1,
                toParse.indexOf("_"));
        String pt2 = toParse.substring(toParse.lastIndexOf("[") + 1,
                toParse.lastIndexOf("_"));
        String name = toParse.substring(toParse.indexOf(" ") + 1,
                toParse.indexOf(":") - 1);
        return new PPVerticalConstraint(name,
                (Point) searchGeoByName(pt1, geometry),
                (Point) searchGeoByName(pt2, geometry));
    }

    private static PPHorizontalConstraint parsePPHorizontal(String toParse, List<Geometry> geometry) {
        String pt1 = toParse.substring(toParse.indexOf("[") + 1,
                toParse.indexOf("_"));
        String pt2 = toParse.substring(toParse.lastIndexOf("[") + 1,
                toParse.lastIndexOf("_"));
        String name = toParse.substring(toParse.indexOf(" ") + 1,
                toParse.indexOf(":") - 1);
        return new PPHorizontalConstraint(name,
                (Point) searchGeoByName(pt1, geometry),
                (Point) searchGeoByName(pt2, geometry));
    }

    private static PPCoincidentConstraint parsePPCoincident(String toParse, List<Geometry> geometry) {
        String pt1 = toParse.substring(toParse.indexOf("[") + 1,
                toParse.indexOf("_"));
        String pt2 = toParse.substring(toParse.lastIndexOf("[") + 1,
                toParse.lastIndexOf("_"));
        String name = toParse.substring(toParse.indexOf(" ") + 1,
                toParse.indexOf(":") - 1);
        return new PPCoincidentConstraint(name,
                (Point) searchGeoByName(pt1, geometry),
                (Point) searchGeoByName(pt2, geometry));
    }

    private static PPDistanceConstraint parsePPDistance(String toParse, List<Geometry> geomerty) {
        String pt1 = toParse.substring(toParse.indexOf("[") + 1,
                toParse.indexOf("_"));
        String pt2 = toParse.substring(toParse.lastIndexOf("[") + 1,
                toParse.lastIndexOf("_"));
        String name = toParse.substring(toParse.indexOf(" ") + 1,
                toParse.indexOf(":") - 1);
        double value = Double.parseDouble(toParse.substring(toParse.lastIndexOf("{") + 1,
                toParse.lastIndexOf("}")));
        return new PPDistanceConstraint(name,
                (Point) searchGeoByName(pt1, geomerty),
                (Point) searchGeoByName(pt2, geomerty),
                sqrt(abs(value)));
    }


}
