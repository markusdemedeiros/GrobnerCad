# Help! What is this program doing?

## Overview
This program is intended to provide solutions to *geometric constraint satisfaction* problems, which arises in mechanical engineering and computer aided design. Given a *dimensioned drawing* like below, the aim is to determine exactly how many configurations of the geometric objects satisfy all of the constraints. 

![Jansen's Linkage in FOSS 2D constraint solver *Solvespace*][Drawing1]

## Background 
We say a dimensioned drawing is *structurally overconstrained* if it contains redundant constraints (constraints which can be deduced from the other constraints in the drawing), *structurally underconstrained* if there is some geometric elements which can move and still satisfy the constraints, and *structurally well constrained* if a solution to the drawing is rigid. Every structurally well constrained drawing has a finite number of solutions. 

A drawing, independent of it's structural well-constrainedness, is *geometrically well constrained* if there is exactly one solution, is *geometrically underconstrained* if there are several solutions, and *geometrically overconstrained* if there are zero solutions (this can happen in an *inconsistent* drawing, where two constraints disagree). 

There are several very fast graph-theoetic algorithms for determining the structural well-constrainedness of a drawing, but in general they cannot tell you about geometric well-constrainedness and as such do not give you much information about the set of solutions. Sometimes this causes solvers to behave unexpectedly with structurally well-constrained drawings, as solvers can converge onto unintended solutions the user does not see. Furthermore, these fast solvers are rarely helpful for determining the motion of intentionally underconstrained drawings. For example, the drawing above (called Jansen's Linkage after it's designer) is intentionally underconstrained so the blue line segment can rotate and drive the grey triangle in a lifelike leg motion.

The slower algorithm this program uses can determine these geometric properties. The problem is reframed in terms of algebraic geometery, where the constraints are represented by a system of higher dimensional polynomials in the real numbers. Algebraic geometery allows us to consider the set solutions to all polynomial equations as the *variety* of the *ideal generated by the polynomials*. 

If two systems of constraints generate the same variety they will have identical solutions. The algorithm is based upon **Buchberger's algorithm**, an algebraic method for reducing an ideal of polynomials to it's **Grobner Basis**. A **Grobner Basis** is a system of equivalent polynomials which generates the same variety, and has terms reduced in a convenient fashion. You can think of it like doing Gaussian elemination on a system of linear equations, in fact Gaussian elimination is just a 1D version of Buchberger's algorithm! 

* If the system is inconsistent, the Grobner basis will contain the 1 polynomial (because the system is satisfied if and only if 1 = 0). 

* If the system is structurally underconstrained, the Grobner basis will have at least one dimension of freedom. The equations remaining describe how exactly that one point moves.

* If a co-ordinate X of a point is structurally and geometrically well constrained, the polynomial X-a will appear in the Grobner basis. 

* Several other techniques from algebraic geometery can be used to examine the space of solutions. 

## Program Operation

1. **Specification Phase**: First, you must input the geometery you want to consider into the program. You could specify as much geometery as you like, but it is highly recommended that you only specify the points you wish to constrain. In the future there will be some detection of unused geometery, but for now it just makes the program slow. For example, in the above picture you would only need to specify the points and not the lines, as the entire specification is in terms of strictly distances. Then, the program will prompt you to begin adding constraints to your specified geometery. 

2. **Solution Phase**: The program will take your constraints, turn them into a system of polynomials and compute the Grobner Basis. There has been some research recently about exploiting group theoretic symmetries to reduce computational load, and in the future this would be implemented here. Buchberger's algorithm runs in double exponential time, so it is generally worthwile to spend time choosing the right paramaters before running the solver. 

3. **Analysis Phase**: Armed with a Grobner Basis, the program will allow you to explore the space of solutions, the remaining polynomials (if any) and utilize elimintaion theory to translate the system of polynomials back into geometric co-ordinates. When the GUI is implemented, we will be able to see a picture. The ultimate goal of this program will be to select a geometric object, and visually see the space in which it could exist alongside the exact polynomial equations describing it's motion. 

[Drawing1]: Solvespace_JansenLinkage.jpeg
